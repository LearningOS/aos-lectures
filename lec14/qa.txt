rcu_read_lock()和
rcu_read_unlock()

,在没有
配置CONFIG_PREEMPT的内核里,这对原语就是空函数。



子假设整个更新操作都持有了一把互斥锁,这意味
着任意时刻最多只会有两个版本的链表。



在任意时刻一个链表能有多少个RCU版本可用?


答案:这依赖于同步设计。如果保护更新操作的信号量保护范围跨
越了宽限期,那么将可能至多两个版本,新链表和旧链表。
但是,假设仅仅搜索、更新及list_replace_rcu()操作被锁所保
护,并且synchronize_rcu()在锁的范围之外,类似于图D.5所示。进一
步假设同时还有大量线程正在进行RCU替换操作,并且读者正在遍历数
据结构。
因此,此时可能有任意多个活跃的版本,其数目只受内存和一个宽
限期能完成的更新次数影响。但是请注意的是频繁更新的数据结构不是
RCU的最佳应用场所。RCU只在必需的情况才处理高频的更新请求。


但是,RCU还是会受到更隐晦的优先级反转问题影响,比如,在等
待RCU宽限期结束时阻塞的高优先级进程,会被-rt内核的低优先级RCU
读者阻塞。这可以用RCU优先级提升[McK07d,GMTW08]解决。


9.3.3.4
 RCU是穷人版的垃圾回收器(garbage collector)

也许思考RCU与垃圾自动回收器(GC)之间关系的最好办法是,
RCU类似自动决定回收时机的GC,但是RCU与GC有2点不同:(1)程
序员必须手动指示何时可以回收指定数据结构;(2)程序员必须手动
标出可以合法持有引用的RCU读端临界区。


也许思考RCU与垃圾自动回收器(GC)之间关系的最好办法是,
RCU类似自动决定回收时机的GC,但是RCU与GC有2点不同:(1)程
序员必须手动指示何时可以回收指定数据结构;(2)程序员必须手动
标出可以合法持有引用的RCU读端临界区。


u rcu?








